% CR(beta/eta) fails for arbitrary PTS

eta : (lam A ([x] (app M x))) --> M.

cex = lam (s p) ([y] (app (lam (s t) [x] x) y)).

%query 2 2   P:  cex --> M. % and they are different

% incomplete implementation of not equal

diff : tm -> tm -> type.

d1 : diff (s p) (s t).
d2 : diff (s t) (s p).
d3l : diff (s _) (lam _ _).
d4l : diff  (lam _ _) (s _).
da1 : diff (app _ _) (s _).
da2 : diff  (s _) (app _ _).
da3 : diff (app _ _) (lam _ _).
da4 : diff  (lam _ _) (app _ _).
dac1 : diff (app E1 E2) (app F1 F2)
	<- diff E1 F1.
dac2 : diff (app E1 E2) (app F1 F2)
	<- diff E2 F2.
dl1 : diff (lam A _) (lam B _)
       <- diff A B.
dl2 : diff (lam A M) (lam A N)
       <- {x} diff (M x) (N x). % incompleteness, see my thesis

% taken from beta in STLC, think about it! eta?

% E = x | s | E N
% N = \x:M. N | E | pi x: N M
neutral : tm -> type.
nf : tm -> type.
nfs: nf (s _).
nfl: nf (lam A M)
      <- nf A
      <- ({x} neutral x -> nf (M x)).
nfl: nf (pi A M)
      <- nf A
      <- ({x} neutral x -> nf (M x)).


nn: nf M <- neutral M.
nfs: neutral (s _).
na: neutral (app M N)
     <- neutral M
	<- nf N.

cexcr : tm -> tm -> type.

% weak form of diamond failure
c : cexcr M1 M2
     <-  cex --> M1
     <-  cex --> M2
     <- nf M1
     <- nf M2
     <- diff M1 M2.

%query 1 1 PP: cexcr M1 M2.

nat : type.
z : nat.
sc : nat -> nat.

1 = sc z.
2 = sc 1.
3 = sc 2.
4 = sc 3.
5 = sc 4.
hei : nat -> tm -> type.
size : nat -> nat -> tm -> type.

h1: hei _ (s p).
h2: hei _ (s t ).
h3: hei (sc H) (app M N)
     <- hei H M
     <- hei H N.
h4: hei (sc H) (lam A M)
     <- ({x} ({h:nat} hei h x) -> hei H (M x))
	<- hei H A.
h5: hei (sc H) (pi A M)
     <- ({x} ({h:nat} hei h x) -> hei H (M x))
	<- hei H A.

% weak form of diamond failure, with generation
gcexcr : nat -> tm -> tm -> type.
c : gcexcr H M1 M2
     <- hei H M
     <-  M --> M1
     <-  M --> M2
     <- nf M1
     <- nf M2
     <- diff M1 M2.

%query 1 1 hei 3 cex.
%% does not convergem shoot
% query 1 1 gcexcr 3 M1 M2.
