% ctx must be ordered! It's not
% generalization with worlds does not work, it's relevant only for axiom...

tm : type.
knd : type.
star : knd.
box : knd.

lam : tm  -> (tm -> tm) -> tm.
app : tm -> tm -> tm.
c : knd -> tm.
arrow : tm -> tm -> tm.



is_kind : tm -> type.
isk : is_kind (c _).

conv : tm -> tm -> type.
has_type: tm -> tm -> type.
% has_sort : tm -> knd -> type.

axiom : has_type (c star) (c box).

t/k_form: has_type (arrow A B) (c K)
	   <- has_type A (c K)
	   <- has_type B (c K).
app/t : has_type (app F M) B
	 <- has_type F (arrow A B)
	 <- has_type M B.

abs/t : has_type (lam A M) (arrow A B)
	 <- ({x} has_type x A -> has_type (M x) B)
	 <- has_type A (c S)
	    <- has_type (arrow A B) (c S). % diff S?

% conv/t: has_type A B'
% 	 <- has_type A B
% 	 <- has_type B' (c S)
% 	    <- conv B B'.

% a : * |- a => a : *
%query 1 1 ({a} has_type a (c star) -> has_type (arrow a a) (c star)).
% a : *, b : *  |- a => b : *
%query 1 1
({a} has_type a (c star) -> {b} has_type b (c star) -> has_type (arrow b a) SS).

% this must be false x: a, a : * |- x : a
% because a is used before being defined
% but it's not
% a : * |- a => a : *
%query 0 1
({x} {a} has_type x a ->
			 has_type a (c star) ->
						has_type x a).
